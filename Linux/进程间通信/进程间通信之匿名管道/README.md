匿名管道（Anonymous Pipe）是 Linux 进程间通信（IPC）的基础机制之一，主要用于​​具有亲缘关系（如父子、兄弟进程）​​ 的进程间单向数据传输。其本质是内核维护的一块内存缓冲区，通过文件描述符进行读写操作，不占用磁盘空间，生命周期随进程结束而终止。
--------------------------------------------------------------------------------
⚙️ ​​核心原理与特性​​
1.​​半双工通信​​
- 数据单向流动：一端写入（fd[1]），一端读取（fd[0]）。
- 若需双向通信，需创建两个管道。
2.​​亲缘关系限制​​
- 仅用于父子、兄弟等有继承关系的进程（因 fork() 会复制文件描述符表）。
3.​​同步与阻塞机制​​
- ​​读空管道​​：阻塞直到有数据写入。
- ​​写满管道​​：阻塞直到有空间（默认缓冲区大小 64KB）。
- ​​读端关闭后写​​：触发 SIGPIPE 信号，终止写入进程。
4.​​内核缓冲区​​
- 数据在内核缓冲区流转，无需磁盘 I/O，高效但需两次拷贝（用户态↔内核态）。
--------------------------------------------------------------------------------
⧋ ​​实现流程​​
1.​​创建管道​​pipe(int fd[2]) 系统调用生成两个文件描述符：fd[0]（读端）、fd[1]（写端）。
2.​​创建子进程​​fork() 复制父进程的文件描述符表，子进程继承同一管道。
3.​​关闭冗余描述符​​

- 父进程关读端（close(fd[0])），子进程关写端（close(fd[1])），实现单向通信。
4.​​读写操作​​

- 父进程 write(fd[1], data)，子进程 read(fd[0], buffer)。
--------------------------------------------------------------------------------
💻 ​​代码示例：父子进程通信​​
以下示例演示父进程向子进程发送消息：
#include <iostream>
#include <unistd.h>
#include <cstring>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    char buffer[1024];
    
    // 1. 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) { // 子进程
        close(pipefd[1]);  // 关闭写端
        ssize_t count = read(pipefd[0], buffer, sizeof(buffer));
        if (count > 0) {
            buffer[count] = '\0';
            std::cout << "子进程收到: " << buffer << std::endl;
        }
        close(pipefd[0]);
        exit(EXIT_SUCCESS);
    } 
    else { // 父进程
        close(pipefd[0]);  // 关闭读端
        const char* msg = "Hello from parent!";
        write(pipefd[1], msg, strlen(msg));
        close(pipefd[1]);
        wait(nullptr); // 等待子进程结束
    }
    return 0;
}
​​运行结果​​：
子进程收到: Hello from parent!
--------------------------------------------------------------------------------
⚠️ ​​关键注意事项​​
1.​​文件描述符泄漏​​

- 务必关闭未使用的描述符，避免资源浪费和阻塞。
2.​​缓冲区限制​​

- 默认管道容量为 ​​64KB​​（可通过 fcntl() 查询），写满时阻塞。
3.​​原子性写入​​

- 单次写入 ≤ ​​4KB​​（PIPE_BUF）时保证原子性（避免数据交错）。
4.​​非阻塞模式​​

- 设置 O_NONBLOCK 标志可使读写非阻塞（返回 EAGAIN 而非等待）。
--------------------------------------------------------------------------------
💎 ​​面试要点总结​​
​​特性​​​​说明​​​​通信方向​​半双工（单向），双向需两个管道​​进程关系​​仅限父子、兄弟等亲缘进程​​生命周期​​随进程结束自动销毁​​同步机制​​读空阻塞、写满阻塞、读端关闭后写触发 SIGPIPE​​性能关键​​内核缓冲区，无磁盘 I/O，但需两次数据拷贝
💡 ​​应用场景​​：命令行工具链（如 ls | grep "txt"）、父子进程日志传递、进程同步。
深入理解匿名管道的底层机制（如缓冲区管理、阻塞逻辑）是面试高频考点，建议结合代码调试分析内核行为。
